using Pl_Covid_19_Anmeldung.connection.exceptions;
using System;
using System.Diagnostics;
using System.IO;
using System.Net.Sockets;
using System.Security.Cryptography;
using System.Threading;

namespace Pl_Covid_19_Anmeldung.connection
{
    class PLCASocket : IDisposable
    {
        /// <summary>
        /// Client id to indicate that the requesting user is the covid-login
        /// </summary>
        private const int CLIENT_ID = 0;

        // The stream to access any read/write functions
        private readonly NetworkStream stream;
        // Socket/Client to access the network functions
        private readonly TcpClient client;

        // The rsa-encryption manager
        private RSACryptoServiceProvider rsaService;

        // The aes-key and aes-iv for the secure encryption (Will be generated by the remote client)
        private readonly byte[] aesKey = new byte[32], aesIv = new byte[16];

        // How long no data got send
        private long lastDataSendTime;

        // Timeout-time (How many ms to wait until the connection gets killed)
        public long Timeout = 5000;

        /// <summary>
        /// 
        /// </summary>
        /// <param name="host"></param>
        /// <param name="port"></param>
        /// <param name="privateKey"></param>
        /// <exception cref="SocketException">If anything went wrong with the connection</exception>
        /// <exception cref="IOException">If anything went wrong during the handshake</exception>
        public PLCASocket(string host,int port,RSAParameters privateKey) 
        {
            try
            {
                // Connects to the remote host
                this.client = new TcpClient(host, port);
                this.stream = this.client.GetStream();
            }
            catch (SocketException)
            {
                // Converts a socket exception to an io-exception for easier handling later
                throw new IOException();
            }

            // Saves the key
            this.rsaService = new RSACryptoServiceProvider();
            // Loads the key
            this.rsaService.ImportParameters(privateKey);

            // Does the handshake
            this.DoHandshake();
        }

        /// <summary>
        /// Does the secure handshake to establish a secure connection with the server
        /// </summary>
        private void DoHandshake()
        {
            // Stores the received data for the aes key (Still encrypted using the rsa-key)
            byte[] aesBytes = new byte[256];

            try
            {
                // Sends the client-id
                this.stream.WriteByte(CLIENT_ID);

                // Receives the aes-data
                for (int i = 0; i < 256; i++)
                    aesBytes[i] = this.ReadByte();

                // TODO: Log
                Console.WriteLine("Received aes-secrets");
            }
            catch
            {
                // Failed to receive the key (or failed to send the id)
                throw new HandshakeException(HandshakeExceptionType.IO);
            }

            try
            {
                // Decryptes the bytes
                byte[] decryptedAes = this.rsaService.Decrypt(aesBytes, false);

                // TODO: Log
                Console.WriteLine("Decrypted successfull");

                // Copies the aes key and aes iv
                Array.Copy(decryptedAes, 0, this.aesKey, 0, 32);
                Array.Copy(decryptedAes, 32, this.aesIv, 0, 16);
            }
            catch
            {
                // Failed to decrypt the aes-key
                throw new HandshakeException(HandshakeExceptionType.RSA_DECRYPT);
            }
        }

        /// <summary>
        /// Uses AES-CBC with padding to decrypt the given data using the aes key and iv from the class
        /// </summary>
        /// <param name="data">The encrypted data</param>
        /// <returns>If the decryption failes, null; otherwise the decrypted data</returns>
        private byte[] Decrypt(byte[] data)
        {
            try
            {
                RijndaelManaged SymmetricKey = new RijndaelManaged
                {
                    Mode = CipherMode.CBC
                };
                byte[] PlainTextBytes = new byte[data.Length];
                int ByteCount = 0;
                using (ICryptoTransform Decryptor = SymmetricKey.CreateDecryptor(this.aesKey, this.aesIv))
                {
                    using (MemoryStream MemStream = new MemoryStream(data))
                    {
                        using (CryptoStream CryptoStream = new CryptoStream(MemStream, Decryptor, CryptoStreamMode.Read))
                        {

                            ByteCount = CryptoStream.Read(PlainTextBytes, 0, PlainTextBytes.Length);
                            MemStream.Close();
                            CryptoStream.Close();
                        }
                    }
                }
                SymmetricKey.Clear();

                byte[] x = new byte[ByteCount];
                Array.Copy(PlainTextBytes, 0, x, 0, ByteCount);
                return x;
                }
            catch
            {
                return null;
            }
        }

        /// <summary>
        /// Uses AES-CBC with padding to encrypt the given data using the aes key and iv from the class
        /// </summary>
        /// <param name="data">The plain data</param>
        /// <returns>If the encryption failes, null; otherwise the encrypted data</returns>
        private byte[] EncryptAES(byte[] data)
        {
            try
            {
                RijndaelManaged SymmetricKey = new RijndaelManaged
                {
                    Mode = CipherMode.CBC
                };
                byte[] CipherTextBytes = null;
                using (ICryptoTransform Encryptor = SymmetricKey.CreateEncryptor(this.aesKey, this.aesIv))
                {
                    using (MemoryStream MemStream = new MemoryStream())
                    {
                        using (CryptoStream CryptoStream = new CryptoStream(MemStream, Encryptor, CryptoStreamMode.Write))
                        {
                            CryptoStream.Write(data, 0, data.Length);
                            CryptoStream.FlushFinalBlock();
                            CipherTextBytes = MemStream.ToArray();
                            MemStream.Close();
                            CryptoStream.Close();
                        }
                    }
                }
                SymmetricKey.Clear();
                return CipherTextBytes;
            }
            catch
            {
                return null;
            }
        }

        /// <summary>
        /// Reads the next byte from the stream. If no data is available the method waits until eighter a new byte becomes available or the stream timeouted
        /// </summary>
        /// <returns>The next byte</returns>
        /// <exception cref="IOException">If the stream timeouted or anything went wrong with the I/O</exception>
        private byte ReadByte()
        {
            // Resets the timeout
            this.lastDataSendTime = DateTimeOffset.Now.ToUnixTimeMilliseconds();

            // Waits until data is available
            while (!this.stream.DataAvailable)
            {
                // Waits
                Thread.Sleep(10);
                // Checks if no data has been available for to long
                if (DateTimeOffset.Now.ToUnixTimeMilliseconds() - this.lastDataSendTime > this.Timeout)
                    throw new IOException("Data-stream timeouted");
            }
            // Gets the next byte
            return (byte)this.stream.ReadByte();
        }

        /// <summary>
        /// Encryptes the given data and sends it as a packet to the receiver
        /// </summary>
        /// <param name="data">The raw bytes that shall be send</param>
        /// <exception cref="IOException">If anything went wrong with the I/O</exception>
        public void SendPacket(params byte[] data)
        {
            try
            {
                // Encryptes the data using the received key
                byte[] encrypted = this.EncryptAES(data);

                // Checks if anything failed with the encryption
                if (encrypted == null)
                    throw new Exception("Encryption failed");

                // Sends the length of the packet
                this.stream.WriteByte((byte)encrypted.Length);
                this.stream.WriteByte((byte)(encrypted.Length >> 8));

                // Sends the actual encrypted data
                this.stream.Write(encrypted, 0, encrypted.Length);
                this.stream.Flush();
            }
            catch(Exception e)
            {
                // Converts any exception to an i/o-exception
                throw new IOException(e.Message);
            }
        }

        /// <summary>
        /// Waits for a new packet from the remote client.
        /// </summary>
        /// <returns>The data</returns>
        /// <exception cref="IOException">If anything went wrong with the I/O</exception>
        public byte[] ReceivePacket()
        {
            try
            {
                // Receives the length of the packet
                int len = this.ReadByte() | (this.ReadByte() << 8);

                // Reserves the space to store the data
                byte[] back = new byte[len];

                // Waits for the data
                for (int i = 0; i < len; i++)
                    back[i] = this.ReadByte();

                // Decrypts the data
                byte[] dec = this.Decrypt(back);

                // Checks if the decryption failed
                if (dec == null)
                    throw new Exception("Data-decryption failed.");

                return dec;
            }
            catch (Exception e)
            {
                // Converts any exception to an i/o-exception
                throw new IOException(e.Message);
            }
        }

        /// <summary>
        /// Kills the connection
        /// </summary>
        public void Dispose()
        {
            // Closes the socket
            if (this.client != null)
                this.client.Close();

            // Closes the stream
            if(this.stream != null)
                this.stream.Close();   
        }
    }
}
